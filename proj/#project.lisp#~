;; ### Globals ################################################################################

(defparameter board nil)
(defparameter score nil)
(defparameter positions-map nil)


;; ### Inputs #################################################################################

(defun get-number ()
  "Receives an input from the user and guarantees that it is a number"
  (let ((value (read)))
    (if (numberp value) (return-from get-number value)))
  (format t "The answer must be a number!~%Please choose a number as an option: ")
  (get-number))


;; ### Loads ##################################################################################

(defun get-path(file)
  "Returns the path to theh files"
  (concatenate 'string "~/Desktop/IA/proj/" file))
  
(load (get-path "puzzle.lisp"))

(defun load-boards (filename)
  "Reads the filename and loads every board in it"
  (let ((result '())
        (current_problem '())
        (current_board '()))
    (with-open-file (file filename :direction :input :if-does-not-exist :error)
      (loop for line = (read-line file nil)
            while line do (cond ((char= #\P (char line 0))
		      (setf current_problem
			    (list (subseq line (1+ (position #\Space line)) (1- (length line))))))
		     ((char= #\O (char line 0)) (push (get-objective line) current_problem))
		     ((char= #\- (char line 0))
		      (push (reverse (copy-list current_board)) current_problem)
		      (push (reverse (copy-list current_problem)) result)
		      (setf current_board '())
		      (setf current_problem '()))
		     (t (push (get-board line) current_board)))))
    (reverse result)))


(defun get-objective (line)
  "Parses the objetive to integer if it is a number, else returns random"
  (let ((objective (subseq line (position #\Space line) (length line))))
    (cond ((char= #\? (char objective 1)) 'RANDOM)
          (t (parse-integer objective)))))


(defun get-board (line)
  "Transforms the current line of the board into a list."
  (cond ((char= #\r (char line 0)) 'RANDOM)
        (t (loop for start = 0 then (1+ end)
		 for end = (or (position #\Space line :start start) (1- (length line)))
		 while (and end (< start (length line)))
		 collect (let ((value (string-trim " " (subseq line start (1+ end)))))
			   (if (equal value "NIL") nil value)))))) ;; Get the values as Strings


;; ### Outputs ################################################################################

(defun print-final-result(node)
  (cond ((null node) (format t  "This problem doesn't have a solution~%"))
	(t 
	 (format t "Objective: ~a Score: ~a~%" score (second node))
	 (format t "Result Board:~%")
	 (dotimes (i 10)
	   (dotimes (j 10)
	     (let ((coordinates (list j i))
		   (value (nth j (nth i board))))
	       (cond ((null value) (format t "-- "))
		     ((equal coordinates (gethash "kn" (first node))) (format t "Kn "))
		     ((not (null (gethash coordinates (first node)))) (format t "-- "))
		     (t (format t "~a " value)))))
	   (format t "~%")))))

(defun populate-positions-map (table)
  (dotimes (i 10)
    (dotimes (j 10)
      (let* ((value (nth j (nth i table)))
	     (position (list j i)))
	(if (not (null value))
	    (setf (gethash value positions-map) position))))))

(defun print-board (board &optional)
  "Prints the board"
  (labels ((print-row(line)
	     "Prints a string"
	     (cond ((null line) nil)
		   ((null (first line))
		    (format t "-- ")
		    (print-row (rest line)))
		   (t (format t "~a " (first line))
		      (print-row (rest line))))))
    (cond ((null board) nil)
	  ((equal 'RANDOM (first board)) (format t "RANDOM~%"))
	  (t (print-row (first board))
	     (format t "~%")
	     (print-board (rest board))))))


(defun print-boards-information (boards)
  "Prints the informations about every board"
  (cond ((null boards) (format t  "-----------------------------~%"))
        ((stringp (first boards)) 
         (format t "Problem ~a:~%" (first boards))
         (print-boards-information (rest boards)))
        ((or (numberp (first boards)) (equal 'random (first boards))) 
         (format t "Objective: ~a~%" (first boards))
         (print-boards-information (rest boards)))
        (t (format t "Board:~%")
         (print-board (first boards))
         (print-boards-information (rest boards)))))


(defun print-boards-list (boards)
  "Print the list of all the boards available"
  (cond ((null boards) nil)
        (t (print-boards-information (first boards))
           (print-boards-list (rest boards)))))


(defun print-hash-map (tbl)
  "Print a map"
  (maphash #'(lambda (key value)
	       (format t "Key: ~a, Position: ~a~%" key value))
	   tbl))


(defun print-hash-map-sorted (tbl)
  "Print a map with its keys sorted"
  (let ((keys ()))
    (maphash #'(lambda (key value)
		 (declare (ignore value))
                 (push key keys))
	     tbl)
    (dolist (key (sort keys 'string<))
      (format t "Key: ~a, Position: ~a~%" key (gethash key tbl)))))


;; ### Main ###################################################################################

(defun get-problem ()
  "Returns the goal to the selected problem"
  (let* ((file (get-path "boards.dat" ))
	 (boards (load-boards file)))
    (print-boards-list boards)
    (format t "Choose the problem (the choice must be a number): ")
    (let* ((option (get-number))
	   (temp nil))
      (cond ((not (or (< option 1) (>= option (length boards))))
	     (setf temp (nth (1- option) boards))
	     (if (stringp (third temp)) (setf board (mount-board
						     (shuffle-positions (list-positions))))
		 (setf board (third temp)))
	     (if (stringp (second temp)) (random 3245) (second temp)))
	    (t (setf board (mount-board (shuffle-positions (list-positions))))
	       (random 3245))))))

(defun init-open-list(&optional calculate_fgh)
  "Initializes the open list of nodes"
  (let ((nodes '()))
    (mapcar #'(lambda(value)
		"Creates the nodes with the values"
	       (let* ((coordinates (gethash value positions-map))
		      (init-state (knight-start-position (first coordinates) (second coordinates)))
		      (child (create-node init-state)))
		 (cond ((null calculate_fgh) (push child nodes))
		       (t (let* ((h (funcall calculate_fgh child))
				 (f (list h 0 h)))
			(push (append child f) nodes))))))
	    (remove-nil (first board)))
    (reverse nodes)))

(defun remove-nil(lst)
  "Removes all the nil values of the list"
  (let ((values '()))
    (mapcar #'(lambda(value)
		(if (not (null value)) (push value values)))
	    lst)
    (reverse values)))

(defun bfs()
  "Breadth-First Search alghorithm"
  (let ((list-open-nodes (init-open-list)))
    (labels ((alghorithm (root)
	       "BFS algorithm"
	       (cond ((<= score (second root)) root)
		     (t (setf list-open-nodes (append list-open-nodes (partenogenese root)))
			(if (not (null list-open-nodes)) (alghorithm (pop list-open-nodes)))))))
      (alghorithm (pop list-open-nodes)))))

(defun dfs()
  "Depth-First Search alghorithm"
  (let ((list-open-nodes (init-open-list)))
    (labels ((alghorithm (root)
	       "DFS algorithm"
	       (cond ((<= score (second root)) root)
		     (t (setf list-open-nodes (append (partenogenese root) list-open-nodes))
			(if (not (null list-open-nodes)) (alghorithm (pop list-open-nodes)))))))
      (alghorithm (pop list-open-nodes)))))

(defun percentual-distance(node)
  "Calculates the percentage that the node has to get to be equal to score"
  (* 100 (/ (second node) score)))

(defun aux-a-percentual-distance(n1 n2)
  "Auxialiar method to sort the value in the open nodes list of A* algorithm. Checks if node1 as a  greater cost than node2"
  (> (fifth n1) (fifth n2)))

(defun a(heuristic)
  "A* alghorithm"
  (let ((list-open-nodes (sort (init-open-list heuristic) #'aux-a-percentual-distance)))
    (labels ((alghorithm (root)
	       "A* algorithm"
	       (cond ((<= score (second root)) root)
		     (t (setf list-open-nodes (sort (append list-open-nodes (partenogenese root heuristic)) #'aux-a-percentual-distance))
			(if (not (null list-open-nodes)) (alghorithm (pop list-open-nodes)))))))
      (alghorithm (pop list-open-nodes)))))

(defun ida()
  "IDA alghorithm"
  (let ((list-open-nodes (sort 

(defun enunciation-heuristic(node)
  "Calculates the average points of the board and divides it by the number of points to be at the objective"
  (labels ((get-keys(map)
	     "Returns a list with only the values in the board as strings"
	     (let ((keys '()))
	       (maphash #'(lambda(k v) (push k keys)) map)
	       keys))
	   (get-sum-values(list-keys)
	     "Returns the sum of the values in the list"
	     (reduce #'(lambda(v1 v2)
			 (cond ((or (equal "kn" v1) (equal "kn" v2)) 0)
			       ((listp v1) (+ (parse-integer (nth (first v1) (nth (second v1) board))) (parse-integer (nth (first v2) (nth (second v2) board)))))
			       ((listp v2) (+ v1 (parse-integer (nth (first v2) (nth (second v2) board)))))
			       ((stringp v1) (+ (parse-integer v1) (parse-integer v2)))
			       (t (+ v1 (parse-integer v2)))))
		     list-keys)))
    (cond ((> score (second node))
	   (let* ((all-values (get-keys positions-map))
		 (removed-values (get-keys (first node)))
		 (length-list (- (length all-values) (length removed-values))))
	     (cond ((> length-list 0)
		    (/
		     (/
		      (- (get-sum-values all-values) (get-sum-values removed-values))
		      length-list)
		     (- score (second node))))
		   (t (/
		       (/
			(- (get-sum-values all-values) (get-sum-values removed-values))
			1)
		       (- score (second node)))))))
	  (t 0))))
      
(defun main ()
  (setf score (get-problem))
  (setf positions-map (make-hash-table :test 'equal))
  (populate-positions-map board)
  (format t "-----------------------------~%Objective:~a~%Board~%" score)
  (print-board board)
  (format t "-----------------------------~%BFS~%")
  (print-final-result (bfs))
  (format t "-----------------------------~%DFS~%")
  (print-final-result (dfs))
  (format t "-----------------------------~%A*~%Heuristic: Percentual Distance~%")
  (print-final-result (a #'percentual-distance))
  (format t "Heuristic: Enunciation~%")
  (print-final-result (a #'enunciation-heuristic)))

(defun test()
  (setf score (get-problem))
  (setf positions-map (make-hash-table :test 'equal))
  (populate-positions-map board)
  (format t "-----------------------------~%A*~%Heuristic: Percentual Distance~%")
  (print-final-result (a #'percentual-distance)))

(defun test1()
  (setf score (get-problem))
  (setf positions-map (make-hash-table :test 'equal))
  (populate-positions-map board)
  (format t "-----------------------------~%DFS~%")
  (print-final-result (dfs)))

(defun test2()
  (setf score (get-problem))
  (setf positions-map (make-hash-table :test 'equal))
  (populate-positions-map board)
  (format t "-----------------------------~%DFS~%")
  (print-final-result (bfs)))